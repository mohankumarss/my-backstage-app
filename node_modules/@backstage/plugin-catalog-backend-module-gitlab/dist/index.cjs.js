'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var backendCommon = require('@backstage/backend-common');
var integration = require('@backstage/integration');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var GitlabDiscoveryEntityProvider = require('./cjs/GitlabDiscoveryEntityProvider-c1949eb0.cjs.js');
require('@backstage/backend-tasks');
var catalogModel = require('@backstage/catalog-model');
var lodash = require('lodash');
var uuid = require('uuid');
require('node-fetch');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class GitLabDiscoveryProcessor {
  constructor(options) {
    __publicField$1(this, "integrations");
    __publicField$1(this, "logger");
    __publicField$1(this, "cache");
    __publicField$1(this, "skipReposWithoutExactFileMatch");
    __publicField$1(this, "skipForkedRepos");
    this.integrations = options.integrations;
    this.cache = options.pluginCache.getClient();
    this.logger = options.logger;
    this.skipReposWithoutExactFileMatch = options.skipReposWithoutExactFileMatch || false;
    this.skipForkedRepos = options.skipForkedRepos || false;
  }
  static fromConfig(config, options) {
    const integrations = integration.ScmIntegrations.fromConfig(config);
    const pluginCache = backendCommon.CacheManager.fromConfig(config).forPlugin("gitlab-discovery");
    return new GitLabDiscoveryProcessor({
      ...options,
      integrations,
      pluginCache
    });
  }
  getProcessorName() {
    return "GitLabDiscoveryProcessor";
  }
  async readLocation(location, _optional, emit) {
    if (location.type !== "gitlab-discovery") {
      return false;
    }
    const startTime = /* @__PURE__ */ new Date();
    const { group, host, branch, catalogPath } = parseUrl(location.target);
    const integration = this.integrations.gitlab.byUrl(`https://${host}`);
    if (!integration) {
      throw new Error(
        `There is no GitLab integration that matches ${host}. Please add a configuration entry for it under integrations.gitlab`
      );
    }
    const client = new GitlabDiscoveryEntityProvider.GitLabClient({
      config: integration.config,
      logger: this.logger
    });
    this.logger.debug(`Reading GitLab projects from ${location.target}`);
    const lastActivity = await this.cache.get(this.getCacheKey());
    const opts = {
      archived: false,
      group,
      page: 1,
      // We check for the existence of lastActivity and only set it if it's present to ensure
      // that the options doesn't include the key so that the API doesn't receive an empty query parameter.
      ...lastActivity && { last_activity_after: lastActivity }
    };
    const projects = GitlabDiscoveryEntityProvider.paginated((options) => client.listProjects(options), opts);
    const res = {
      scanned: 0,
      matches: []
    };
    for await (const project of projects) {
      res.scanned++;
      if (branch === "*" && project.default_branch === void 0) {
        continue;
      }
      if (this.skipReposWithoutExactFileMatch) {
        const project_branch = branch === "*" ? project.default_branch : branch;
        const projectHasFile = await client.hasFile(
          project.path_with_namespace,
          project_branch,
          catalogPath
        );
        if (!projectHasFile) {
          continue;
        }
      }
      if (this.skipForkedRepos && project.hasOwnProperty("forked_from_project")) {
        continue;
      }
      res.matches.push(project);
    }
    for (const project of res.matches) {
      const project_branch = branch === "*" ? project.default_branch : branch;
      emit(
        pluginCatalogNode.processingResult.location({
          type: "url",
          // The format expected by the GitLabUrlReader:
          // https://gitlab.com/groupA/teams/teamA/subgroupA/repoA/-/blob/branch/filepath
          //
          // This unfortunately will trigger another API call in `getGitLabFileFetchUrl` to get the project ID.
          // The alternative is using the `buildRawUrl` function, which does not support subgroups, so providing a raw
          // URL here won't work either.
          target: `${project.web_url}/-/blob/${project_branch}/${catalogPath}`,
          presence: "optional"
        })
      );
    }
    await this.cache.set(this.getCacheKey(), startTime.toISOString());
    const duration = ((Date.now() - startTime.getTime()) / 1e3).toFixed(1);
    this.logger.debug(
      `Read ${res.scanned} GitLab repositories in ${duration} seconds`
    );
    return true;
  }
  getCacheKey() {
    return `processors/${this.getProcessorName()}/last-activity`;
  }
}
function parseUrl(urlString) {
  const url = new URL(urlString);
  const path = url.pathname.slice(1).split("/");
  const blobIndex = path.findIndex((p) => p === "blob");
  if (blobIndex !== -1 && path.length > blobIndex + 2) {
    const group = blobIndex > 0 ? path.slice(0, blobIndex).join("/") : void 0;
    return {
      group,
      host: url.host,
      branch: decodeURIComponent(path[blobIndex + 1]),
      catalogPath: decodeURIComponent(path.slice(blobIndex + 2).join("/"))
    };
  }
  throw new Error(`Failed to parse ${urlString}`);
}

function defaultGroupNameTransformer(options) {
  if (options.providerConfig.group && options.group.full_path.startsWith(`${options.providerConfig.group}/`)) {
    return options.group.full_path.replace(`${options.providerConfig.group}/`, "").replaceAll("/", "-");
  }
  return options.group.full_path.replaceAll("/", "-");
}
function defaultGroupEntitiesTransformer(options) {
  const idMapped = {};
  const entities = [];
  for (const group of options.groups) {
    idMapped[group.id] = group;
  }
  for (const group of options.groups) {
    const annotations = {};
    annotations[`${options.providerConfig.host}/team-path`] = group.full_path;
    const entity = {
      apiVersion: "backstage.io/v1alpha1",
      kind: "Group",
      metadata: {
        name: options.groupNameTransformer({
          group,
          providerConfig: options.providerConfig
        }),
        annotations
      },
      spec: {
        type: "team",
        children: [],
        profile: {
          displayName: group.name
        }
      }
    };
    if (group.description) {
      entity.metadata.description = group.description;
    }
    if (group.parent_id && idMapped.hasOwnProperty(group.parent_id)) {
      entity.spec.parent = options.groupNameTransformer({
        group: idMapped[group.parent_id],
        providerConfig: options.providerConfig
      });
    }
    entities.push(entity);
  }
  return entities;
}
function defaultUserTransformer(options) {
  var _a, _b;
  const annotations = {};
  annotations[`${options.integrationConfig.host}/user-login`] = options.user.web_url;
  if ((_b = (_a = options.user) == null ? void 0 : _a.group_saml_identity) == null ? void 0 : _b.extern_uid) {
    annotations[`${options.integrationConfig.host}/saml-external-uid`] = options.user.group_saml_identity.extern_uid;
  }
  const entity = {
    apiVersion: "backstage.io/v1alpha1",
    kind: "User",
    metadata: {
      name: options.user.username,
      annotations
    },
    spec: {
      profile: {
        displayName: options.user.name || void 0,
        picture: options.user.avatar_url || void 0
      },
      memberOf: []
    }
  };
  if (options.user.email) {
    if (!entity.spec) {
      entity.spec = {};
    }
    if (!entity.spec.profile) {
      entity.spec.profile = {};
    }
    entity.spec.profile.email = options.user.email;
  }
  if (options.user.groups) {
    for (const group of options.user.groups) {
      if (!entity.spec.memberOf) {
        entity.spec.memberOf = [];
      }
      entity.spec.memberOf.push(
        options.groupNameTransformer({
          group,
          providerConfig: options.providerConfig
        })
      );
    }
  }
  return entity;
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class GitlabOrgDiscoveryEntityProvider {
  constructor(options) {
    __publicField(this, "config");
    __publicField(this, "integration");
    __publicField(this, "logger");
    __publicField(this, "scheduleFn");
    __publicField(this, "connection");
    __publicField(this, "userTransformer");
    __publicField(this, "groupEntitiesTransformer");
    __publicField(this, "groupNameTransformer");
    var _a, _b, _c;
    this.config = options.config;
    this.integration = options.integration;
    this.logger = options.logger.child({
      target: this.getProviderName()
    });
    this.scheduleFn = this.createScheduleFn(options.taskRunner);
    this.userTransformer = (_a = options.userTransformer) != null ? _a : defaultUserTransformer;
    this.groupEntitiesTransformer = (_b = options.groupEntitiesTransformer) != null ? _b : defaultGroupEntitiesTransformer;
    this.groupNameTransformer = (_c = options.groupNameTransformer) != null ? _c : defaultGroupNameTransformer;
  }
  static fromConfig(config, options) {
    if (!options.schedule && !options.scheduler) {
      throw new Error("Either schedule or scheduler must be provided.");
    }
    const providerConfigs = GitlabDiscoveryEntityProvider.readGitlabConfigs(config);
    const integrations = integration.ScmIntegrations.fromConfig(config).gitlab;
    const providers = [];
    providerConfigs.forEach((providerConfig) => {
      var _a;
      const integration = integrations.byHost(providerConfig.host);
      if (!providerConfig.orgEnabled) {
        return;
      }
      if (!integration) {
        throw new Error(
          `No gitlab integration found that matches host ${providerConfig.host}`
        );
      }
      if (!providerConfig.group && providerConfig.host === "gitlab.com") {
        throw new Error(
          `Missing 'group' value for GitlabOrgDiscoveryEntityProvider:${providerConfig.id}.`
        );
      }
      if (!options.schedule && !providerConfig.schedule) {
        throw new Error(
          `No schedule provided neither via code nor config for GitlabOrgDiscoveryEntityProvider:${providerConfig.id}.`
        );
      }
      const taskRunner = (_a = options.schedule) != null ? _a : options.scheduler.createScheduledTaskRunner(providerConfig.schedule);
      providers.push(
        new GitlabOrgDiscoveryEntityProvider({
          ...options,
          config: providerConfig,
          integration,
          taskRunner
        })
      );
    });
    return providers;
  }
  getProviderName() {
    return `GitlabOrgDiscoveryEntityProvider:${this.config.id}`;
  }
  async connect(connection) {
    this.connection = connection;
    await this.scheduleFn();
  }
  createScheduleFn(taskRunner) {
    return async () => {
      const taskId = `${this.getProviderName()}:refresh`;
      return taskRunner.run({
        id: taskId,
        fn: async () => {
          const logger = this.logger.child({
            class: GitlabOrgDiscoveryEntityProvider.prototype.constructor.name,
            taskId,
            taskInstanceId: uuid__namespace.v4()
          });
          try {
            await this.refresh(logger);
          } catch (error) {
            logger.error(
              `${this.getProviderName()} refresh failed, ${error}`,
              error
            );
          }
        }
      });
    };
  }
  async refresh(logger) {
    var _a, _b, _c, _d;
    if (!this.connection) {
      throw new Error(
        `Gitlab discovery connection not initialized for ${this.getProviderName()}`
      );
    }
    const client = new GitlabDiscoveryEntityProvider.GitLabClient({
      config: this.integration.config,
      logger
    });
    let groups;
    let users;
    if (client.isSelfManaged()) {
      groups = GitlabDiscoveryEntityProvider.paginated((options) => client.listGroups(options), {
        page: 1,
        per_page: 100
      });
      users = GitlabDiscoveryEntityProvider.paginated((options) => client.listUsers(options), {
        page: 1,
        per_page: 100,
        active: true
      });
    } else {
      groups = (await client.listDescendantGroups(this.config.group)).items;
      const rootGroup = this.config.group.split("/")[0];
      users = GitlabDiscoveryEntityProvider.paginated(
        (options) => client.listSaaSUsers(rootGroup, options),
        {
          page: 1,
          per_page: 100
        }
      );
    }
    const idMappedUser = {};
    const res = {
      scanned: 0,
      matches: []
    };
    const groupRes = {
      scanned: 0,
      matches: []
    };
    for await (const user of users) {
      if (!this.config.userPattern.test((_b = (_a = user.email) != null ? _a : user.username) != null ? _b : "")) {
        continue;
      }
      res.scanned++;
      if (user.state !== "active") {
        continue;
      }
      idMappedUser[user.id] = user;
      res.matches.push(user);
    }
    for await (const group of groups) {
      if (!this.config.groupPattern.test((_c = group.full_path) != null ? _c : "")) {
        continue;
      }
      if (this.config.group && !group.full_path.startsWith(`${this.config.group}/`)) {
        continue;
      }
      groupRes.scanned++;
      groupRes.matches.push(group);
      let groupUsers = { items: [] };
      try {
        groupUsers = await client.getGroupMembers(group.full_path, ["DIRECT"]);
      } catch (e) {
        logger.error(
          `Failed fetching users for group '${group.full_path}': ${e}`
        );
      }
      for (const groupUser of groupUsers.items) {
        const user = idMappedUser[groupUser.id];
        if (user) {
          user.groups = ((_d = user.groups) != null ? _d : []).concat(group);
        }
      }
    }
    const groupsWithUsers = groupRes.matches.filter((group) => {
      return res.matches.filter((x) => {
        var _a2;
        return !!((_a2 = x.groups) == null ? void 0 : _a2.find((y) => y.id === group.id));
      }).length > 0;
    });
    const userEntities = res.matches.map(
      (p) => this.userTransformer({
        user: p,
        integrationConfig: this.integration.config,
        providerConfig: this.config,
        groupNameTransformer: this.groupNameTransformer
      })
    );
    const groupEntities = this.groupEntitiesTransformer({
      groups: groupsWithUsers,
      providerConfig: this.config,
      groupNameTransformer: this.groupNameTransformer
    });
    await this.connection.applyMutation({
      type: "full",
      entities: [...userEntities, ...groupEntities].map((entity) => ({
        locationKey: this.getProviderName(),
        entity: this.withLocations(
          this.integration.config.host,
          this.integration.config.baseUrl,
          entity
        )
      }))
    });
  }
  withLocations(host, baseUrl, entity) {
    var _a;
    const location = entity.kind === "Group" ? `url:${baseUrl}/${(_a = entity.metadata.annotations) == null ? void 0 : _a[`${host}/team-path`]}` : `url:${baseUrl}/${entity.metadata.name}`;
    return lodash.merge(
      {
        metadata: {
          annotations: {
            [catalogModel.ANNOTATION_LOCATION]: location,
            [catalogModel.ANNOTATION_ORIGIN_LOCATION]: location
          }
        }
      },
      entity
    );
  }
}

exports.GitlabDiscoveryEntityProvider = GitlabDiscoveryEntityProvider.GitlabDiscoveryEntityProvider;
exports.GitLabDiscoveryProcessor = GitLabDiscoveryProcessor;
exports.GitlabOrgDiscoveryEntityProvider = GitlabOrgDiscoveryEntityProvider;
//# sourceMappingURL=index.cjs.js.map
